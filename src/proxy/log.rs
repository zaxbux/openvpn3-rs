//! # DBus interface proxy for: `net.openvpn.v3.log`
//!
//! This code was generated by `zbus-xmlgen` `3.1.0` from DBus introspection data.
//! Source: `net.openvpn.v3.log.xml`.

use zbus::dbus_proxy;

use self::constants::*;

/// Log Service
///
/// Log service which receives all Log events from all of the OpenVPN 3 Linux services.
///
/// [OpenVPN Documentation](https://github.com/OpenVPN/openvpn3-linux/blob/master/docs/dbus/dbus-service-net.openvpn.v3.log.md)
#[dbus_proxy(
    interface = "net.openvpn.v3.log",
    default_service = "net.openvpn.v3.log",
    default_path = "/net/openvpn/v3/log"
)]
trait Log {
    /// AssignSession method
    ///
    /// A `net.openvpn.v3.backend.be${PID}` service can through this method add a link between the Session D-Bus path to a specific VPN client service. This is required to have happened before the `net.openvpn.v3.log` service can do a lookup from a session path to log events coming from a specific client backend.
    ///
    /// # Arguments
    ///
    /// * `session_path` - D-Bus Session Path to the session this client is responsible for.
    /// * `interface` - String containing the client interface log events are related to.
    fn assign_session(
        &self,
        session_path: &zbus::zvariant::ObjectPath<'_>,
        interface: &str,
    ) -> zbus::Result<()>;

    /// Attach method
    ///
    /// This makes the log service aware of a Log signal producer which it needs to subscribe to. At the same time, the Log signal producer will then target these signals only to the `net.openvpn.v3.log` D-Bus service.
    ///
    /// # Arguments
    ///
    /// * `interface` - String containing the service interface to subscribe to. If a service sends Log signals with different signals, each of these interfaces must be Attached.
    fn attach(&self, interface: &str) -> zbus::Result<()>;

    /// Detach method
    ///
    /// This is the reverse operation of `Attach()`, where the log service will unsubscribe from a specific log producing sender. This is important to avoid resource leaking in the log service. Attached subscriptions should not hurt the performance if they never send signals, but it should be avoided to have too many idling subscriptions.
    ///
    /// # Arguments
    ///
    /// * `interface` - String containing the service interface to unsubscribe from. If a service sends Log signals with different signals, each of these interfaces must be Detached.
    fn detach(&self, interface: &str) -> zbus::Result<()>;

    /// GetSubscriberList method
    ///
    /// Retrieve a list of all subscriptions the log service is attached to. The entries listed here are services which have used the `Attach()` method in this service. Services calling the `Detach()` method will be unlisted.
    ///
    /// # Returns
    ///
    /// An array of subscriber tuples:
    ///
    /// 0. String containing a `tag` value which is used in the logs.
    /// 1. String containing the bus name the log service is attached to.
    /// 2. String containing the D-Bus object interface the subscription is tied to.
    /// 3. String containing the D-Bus object path the subscription is tied to.
    fn get_subscriber_list(&self) -> zbus::Result<Vec<(String, String, String, String)>>;

    /// ProxyLogEvents method
    ///
    /// This method is by design only available by the *openvpn* user, which the `net.openvpn.v3.sessions` service is running under. The Session Manager can call this method to setup a new log recipient for a given VPN session. In addition to Log events being forwarded, StatusChange signals are also part of this feature.
    ///
    /// * `target_address` - D-Bus unique bus name for the recipient of Log and StatusChange events.
    /// * `session_path` - D-Bus object path to the VPN session object.
    ///
    /// # Returns
    ///
    /// D-Bus object path to the Log Proxy object in the logger service.
    #[dbus_proxy(object = "LogNode")]
    fn proxy_log_events(&self, target_address: &str, session_path: &zbus::zvariant::ObjectPath<'_>);

    /// Filename of the config/state file openvpn3-service-logger parsed at start-up.
    #[dbus_proxy(property, name = "config_file")]
    fn config_file(&self) -> zbus::Result<String>;

    /// Should each Log event being processed carry a meta data line before with details about the D-Bus sender of the Log signal?
    #[dbus_proxy(property, name = "log_dbus_details")]
    fn log_dbus_details(&self) -> zbus::Result<bool>;
    fn set_log_dbus_details(&self, value: bool) -> zbus::Result<()>;

    /// How verbose should the logging be.
    #[dbus_proxy(property, name = "log_level")]
    fn log_level(&self) -> zbus::Result<LogLevel>;
    fn set_log_level(&self, value: LogLevel) -> zbus::Result<()>;

    /// Indicates which logging method is in use.
    #[dbus_proxy(property, name = "log_method")]
    fn log_method(&self) -> zbus::Result<String>;

    /// Configures if logged messages should be prefixed with the log senders LogTag hash value.
    #[dbus_proxy(property, name = "log_prefix_logtag")]
    fn log_prefix_logtag(&self) -> zbus::Result<bool>;
    fn set_log_prefix_logtag(&self, value: bool) -> zbus::Result<()>;

    /// Number of attached subscriptions.
    #[dbus_proxy(property, name = "num_attached")]
    fn num_attached(&self) -> zbus::Result<u32>;

    /// Should each log line be prefixed with a timestamp?
    #[dbus_proxy(property, name = "timestamp")]
    fn timestamp(&self) -> zbus::Result<bool>;
    fn set_timestamp(&self, value: bool) -> zbus::Result<()>;

    /// Version information about the running service.
    #[dbus_proxy(property, name = "version")]
    fn version(&self) -> zbus::Result<String>;
}

#[dbus_proxy(
    interface = "net.openvpn.v3.log",
    default_service = "net.openvpn.v3.log",
    default_path = "/net/openvpn/v3/log"
)]
trait LogNode {
    /// Remove method
    ///
    /// By calling this method, the Log and StatusChange forwarding will be stopped. This will also remove this D-Bus object.
    fn remove(&self) -> zbus::Result<()>;

    /// Verbosity level for log events to this recipient
    #[dbus_proxy(property, name = "log_level")]
    fn log_level(&self) -> zbus::Result<LogLevel>;
    fn set_log_level(&self, value: LogLevel) -> zbus::Result<()>;

    /// D-Bus object path to the VPN session.
    #[dbus_proxy(property, name = "session_path")]
    fn session_path(&self) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// D-Bus unique bus name to the recipient (D-Bus client)
    #[dbus_proxy(property, name = "target")]
    fn target(&self) -> zbus::Result<String>;
}

pub mod constants {
    use std::fmt;

    use serde_repr::{Deserialize_repr, Serialize_repr};
    use static_assertions::assert_impl_all;
    use zbus::zvariant::{OwnedValue, Type};

    /// Log Group
    ///
    /// Source: openvpn3-linux/src/log/log-helpers.hpp
    #[repr(u8)]
    #[derive(Deserialize_repr, Serialize_repr, Copy, Clone, Type, Debug, PartialEq, Eq)]
    pub enum LogGroup {
        /// Default - should not be used in code, but is here to detect errors
        UNDEFINED,
        /// Master process (main openvpn-manager)
        MASTERPROC,
        /// Configuration Manager process (child of openvpn-manager
        CONFIGMGR,
        /// Session manager process (child of openvpn-manager)
        SESSIONMGR,
        /// Backend starter process (openvpn3-service-backendstart)
        BACKENDSTART,
        /// Logger process (child of openvpn-manager)
        LOGGER,
        /// Session process (openvpn-service-client)
        BACKENDPROC,
        /// OpenVPN 3 Core tunnel object in the session process
        CLIENT,
        /// Network Configuration service (openvpn3-service-netcfg
        NETCFG,
        /// External services integrating with openvpn3-service-logger
        EXTSERVICE,
    }

    impl fmt::Display for LogGroup {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                LogGroup::UNDEFINED => write!(f, "[[UNDEFINED]]"),
                LogGroup::MASTERPROC => write!(f, "Master Process"),
                LogGroup::CONFIGMGR => write!(f, "Config Manager"),
                LogGroup::SESSIONMGR => write!(f, "Session Manager"),
                LogGroup::BACKENDSTART => write!(f, "Backend Starter"),
                LogGroup::LOGGER => write!(f, "Logger"),
                LogGroup::BACKENDPROC => write!(f, "Backend Session Process"),
                LogGroup::CLIENT => write!(f, "Client"),
                LogGroup::NETCFG => write!(f, "Network Configuration"),
                LogGroup::EXTSERVICE => write!(f, "External Service"),
            }
        }
    }

    assert_impl_all!(LogGroup: Send, Sync, Unpin);

    /// Log Category
    ///
    /// Source: openvpn3-linux/src/log/log-helpers.hpp
    #[repr(u8)]
    #[derive(Deserialize_repr, Serialize_repr, Copy, Clone, Type, Debug, PartialEq, Eq)]
    pub enum LogCategory {
        /// Undefined/not set
        UNDEFINED,
        /// Debug messages
        DEBUG,
        /// Even more details
        VERB2,
        /// More details
        VERB1,
        /// Informational messages
        INFO,
        /// Warnings - important issues which might need attentio
        WARN,
        /// Errors - These must be fixed for successful operation
        ERROR,
        /// Critical - These requires users attention
        CRIT,
        /// Fatal errors - The current operation is going to stop
        FATAL,
    }

    assert_impl_all!(LogCategory: Send, Sync, Unpin);

    impl fmt::Display for LogCategory {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                LogCategory::UNDEFINED => write!(f, "[[UNDEFINED]]"),
                LogCategory::DEBUG => write!(f, "DEBUG"),
                LogCategory::VERB2 => write!(f, "VERB2"),
                LogCategory::VERB1 => write!(f, "VERB1"),
                LogCategory::INFO => write!(f, "INFO"),
                LogCategory::WARN => write!(f, "WARNING"),
                LogCategory::ERROR => write!(f, "-- ERROR --"),
                LogCategory::CRIT => write!(f, "!! CRITICAL !!"),
                LogCategory::FATAL => write!(f, "**!! FATAL !!**"),
            }
        }
    }

    /// Log Level Filter
    ///
    /// Source: openvpn3-linux/src/log/dbus-log.hpp
    #[repr(u8)]
    #[derive(Deserialize_repr, Serialize_repr, Copy, Clone, Type, Debug, PartialEq, Eq)]
    pub enum LogLevel {
        /// Log level 0 - Only FATAL and Critical messages are logged
        FATAL,
        /// Log level 1 - includes log level 0 + Error messages
        ERROR,
        /// Log level 2 - includes log level 1 + Warning messages
        WARNING,
        /// Log level 3 - includes log level 2 + informational messages
        INFO,
        /// Log level 4 - includes log level 3 + Verb 1 messages
        VERB1,
        /// Log level 5 - includes log level 4 + Verb 2 messages
        VERB2,
        /// Log level 6 - includes log level 5 + Debug messages (everything)
        DEBUG,
    }

    assert_impl_all!(LogLevel: Send, Sync, Unpin);

    impl TryFrom<OwnedValue> for LogLevel {
        type Error = <u8 as TryFrom<OwnedValue>>::Error;

        fn try_from(v: OwnedValue) -> Result<Self, Self::Error> {
            Ok(unsafe { std::mem::transmute(<u8>::try_from(v)?) })
        }
    }

    impl fmt::Display for LogLevel {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                LogLevel::FATAL => write!(f, "FATAL"),
                LogLevel::ERROR => write!(f, "ERROR"),
                LogLevel::WARNING => write!(f, "WARNING"),
                LogLevel::INFO => write!(f, "INFO"),
                LogLevel::VERB1 => write!(f, "VERB1"),
                LogLevel::VERB2 => write!(f, "VERB2"),
                LogLevel::DEBUG => write!(f, "DEBUG"),
            }
        }
    }
}
