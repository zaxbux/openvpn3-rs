//! # DBus interface proxy for: `net.openvpn.v3.sessions`
//!
//! This code was generated by `zbus-xmlgen` `3.1.0` from DBus introspection data.
//! Source: `net.openvpn.v3.sessions.xml`.

use self::constants::*;
use super::sessions_node::{SessionsNodeProxy, SessionsNodeProxyBlocking};
use crate::log::constants::{LogGroup, LogLevel};
use zbus::dbus_proxy;

/// Session Service
///
/// Manages all VPN profiles being set up and throughout the whole life cycle until the VPN tunnel is disconnected.
///
/// [OpenVPN Documentation](https://github.com/OpenVPN/openvpn3-linux/blob/master/docs/dbus/dbus-service-net.openvpn.v3.sessions.md)
#[dbus_proxy(
    interface = "net.openvpn.v3.sessions",
    default_service = "net.openvpn.v3.sessions",
    default_path = "/net/openvpn/v3/sessions"
)]
trait Sessions {
    /// FetchAvailableSessions method
    ///
    /// This method will return an array of object paths to session objects the caller is granted access to.
    fn fetch_available_sessions(&self) -> zbus::Result<Vec<zbus::zvariant::OwnedObjectPath>>;

    /// FetchManagedInterfaces method
    ///
    /// This method will return an array of strings containing the virtual network interfaces the session manager is handling. Only interfaces the calling user is granted access to manage will be returned.
    fn fetch_managed_interfaces(&self) -> zbus::Result<Vec<String>>;

    /// LookupConfigName method
    ///
    /// This method will return an array of paths to session objects the caller is granted access to, which where started with the configuration profile name provided to the method. The profile name in the session object will not change if it is changed in the configuration manager after the session has started.
    ///
    /// # Arguments
    ///
    /// * `config_name` - String containing the configuration profile name to lookup.
    #[dbus_proxy(object = "SessionsNode")]
    fn lookup_config_name(&self, config_name: &str);

    /// LookupInterface method
    ///
    /// This method will return the D-Bus path to session object related to the virtual network interface name being looked up. This method will also return paths to interfaces not managed by the user.
    ///
    /// # Arguments
    ///
    /// * `device_name` - String containing the interface name to lookup.
    #[dbus_proxy(object = "SessionsNode")]
    fn lookup_interface(&self, device_name: &str);

    /// NewTunnel method
    ///
    /// This starts a new VPN backend client process for a specific VPN configuration profile. This does not start the connection, it just starts a privileged client process and awaits further instructions. When this method call returns with a session path, it means the backend process have started.
    ///
    /// # Arguments
    ///
    /// * `config_path` -  A string containing the D-Bus object path of the VPN profile.
    ///
    /// # Returns
    /// A string containing a unique D-Bus object path to the created VPN session.
    #[dbus_proxy(object = "SessionsNode")]
    fn new_tunnel(&self, config_path: &zbus::zvariant::ObjectPath<'_>);

    /// TransferOwnership method
    ///
    /// This method transfers the ownership of a session to the given UID value. This feature is by design restricted to the `root` account only and is only expected to be used by `openvpn3-autoload` and similar tools.
    ///
    /// # Arguments
    ///
    /// * `path` - Session object path where to modify the owner property.
    /// * `new_owner_id` - UID value of the new session owner.
    fn transfer_ownership(
        &self,
        path: &zbus::zvariant::ObjectPath<'_>,
        new_owner_uid: u32,
    ) -> zbus::Result<()>;

    /// Log signal
    ///
    /// Whenever the configuration manager want to log something, it issues a Log signal which carries a log group, log verbosity level and a string with the log message itself.
    /// See the separate [logging documentation](https://github.com/OpenVPN/openvpn3-linux/blob/master/docs/dbus/dbus-logging.md) for details on this signal.
    #[dbus_proxy(signal)]
    fn log(&self, group: LogGroup, level: LogLevel, message: &str) -> zbus::Result<()>;

    /// SessionManagerEvent signal
    ///
    /// This signals is sent each time there is a change in regards to active VPN sessions on the system. This is a broadcast signal which is sent to all users on the system containing a bare minimum of details of the related VPN session object.
    #[dbus_proxy(signal)]
    fn session_manager_event(
        &self,
        path: zbus::zvariant::ObjectPath<'_>,
        event_type: EventType,
        owner: u32,
    ) -> zbus::Result<()>;

    /// version property
    #[dbus_proxy(property, name = "version")]
    fn version(&self) -> zbus::Result<String>;
}

pub mod constants {
    use std::fmt;

    use serde_repr::{Deserialize_repr, Serialize_repr};
    use static_assertions::assert_impl_all;
    use zbus::zvariant::Type;

    /// Session Manager Event Type
    ///
    /// Source: openvpn3-linux/src/sessionmgr/sessionmgr-events.hpp
    #[repr(u16)]
    #[derive(Deserialize_repr, Serialize_repr, Copy, Clone, Type, Debug, PartialEq, Eq)]
    pub enum EventType {
        /// Should not be used, identifies an uninitialized object or an error.
        Unset = 0,
        /// A new VPN session was created. It might not yet be started.
        SessCreated = 1,
        /// An existing session object was destroyed, the session was disconnected.
        SessDestroyed = 2,
    }

    assert_impl_all!(EventType: Send, Sync, Unpin);

    impl fmt::Display for EventType {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::Unset => write!(f, "(unset)"),
                Self::SessCreated => write!(f, "Session Created"),
                Self::SessDestroyed => write!(f, "Session Destroyed"),
            }
        }
    }
}
