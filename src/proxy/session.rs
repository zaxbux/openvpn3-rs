//! # DBus interface proxy for: `net.openvpn.v3.sessions`
//!
//! This code was generated by `zbus-xmlgen` `3.1.0` from DBus introspection data.
//! Source: `net.openvpn.v3.session.xml`.

use serde::{Deserialize, Serialize};
use static_assertions::assert_impl_all;
use std::fmt;
use zbus::fdo;
use zbus::zvariant::Type;
use zbus::{dbus_proxy, zvariant::OwnedValue};

use crate::constants::{
    ClientAttentionGroup, ClientAttentionType, LogGroup, LogLevel, StatusMajor, StatusMinor,
};

#[dbus_proxy(
    interface = "net.openvpn.v3.sessions",
    default_service = "net.openvpn.v3.sessions",
    default_path = "/net/openvpn/v3/sessions"
)]
pub trait Session {
    /// AccessGrant method
    fn access_grant(&self, uid: u32) -> zbus::Result<()>;

    /// AccessRevoke method
    fn access_revoke(&self, uid: u32) -> zbus::Result<()>;

    /// Connect method
    fn connect(&self) -> zbus::Result<()>;

    /// Disconnect method
    fn disconnect(&self) -> zbus::Result<()>;

    /// LogForward method
    fn log_forward(&self, enable: bool) -> zbus::Result<()>;

    /// Pause method
    fn pause(&self, reason: &str) -> zbus::Result<()>;

    /// Ready method
    fn ready(&self) -> zbus::Result<()>;

    /// Restart method
    fn restart(&self) -> zbus::Result<()>;

    /// Resume method
    fn resume(&self) -> zbus::Result<()>;

    /// UserInputProvide method
    fn user_input_provide(
        &self,
        type_: ClientAttentionType,
        group: ClientAttentionGroup,
        id: u32,
        value: &str,
    ) -> zbus::Result<()>;

    /// UserInputQueueCheck method
    fn user_input_queue_check(
        &self,
        type_: ClientAttentionType,
        group: ClientAttentionGroup,
    ) -> zbus::Result<Vec<u32>>;

    /// UserInputQueueFetch method
    fn user_input_queue_fetch(
        &self,
        type_: ClientAttentionType,
        group: ClientAttentionGroup,
        id: u32,
    ) -> zbus::Result<(
        ClientAttentionType,
        ClientAttentionGroup,
        u32,
        String,
        String,
        bool,
    )>;

    /// UserInputQueueGetTypeGroup method
    fn user_input_queue_get_type_group(
        &self,
    ) -> zbus::Result<Vec<(ClientAttentionType, ClientAttentionGroup)>>;

    /// AttentionRequired signal
    #[dbus_proxy(signal)]
    fn attention_required(
        &self,
        type_: ClientAttentionType,
        group: ClientAttentionGroup,
        message: &str,
    ) -> zbus::Result<()>;

    /// Log signal
    #[dbus_proxy(signal, name = "Log")]
    fn log(&self, group: LogGroup, level: LogLevel, message: &str) -> zbus::Result<()>;

    /// StatusChange signal
    #[dbus_proxy(signal)]
    fn status_change(
        &self,
        code_major: StatusMajor,
        code_minor: StatusMinor,
        message: &str,
    ) -> zbus::Result<()>;

    /// acl property
    #[dbus_proxy(property, name = "acl")]
    fn acl(&self) -> zbus::Result<Vec<u32>>;

    /// backend_pid property
    #[dbus_proxy(property, name = "backend_pid")]
    fn backend_pid(&self) -> zbus::Result<u32>;

    /// config_name property
    #[dbus_proxy(property, name = "config_name")]
    fn config_name(&self) -> zbus::Result<String>;

    /// config_path property
    #[dbus_proxy(property, name = "config_path")]
    fn config_path(&self) -> zbus::Result<zbus::zvariant::OwnedObjectPath>;

    /// dco property
    #[dbus_proxy(property, name = "dco")]
    fn dco(&self) -> zbus::Result<bool>;
    fn set_dco(&self, value: bool) -> fdo::Result<()>;

    /// device_name property
    #[dbus_proxy(property, name = "device_name")]
    fn device_name(&self) -> zbus::Result<String>;

    /// device_path property
    #[dbus_proxy(property, name = "device_path")]
    fn device_path(&self) -> zbus::Result<String>;

    /// last_log property
    #[dbus_proxy(property, name = "last_log")]
    fn last_log(
        &self,
    ) -> zbus::Result<std::collections::HashMap<String, zbus::zvariant::OwnedValue>>;

    /// log_forwards property
    #[dbus_proxy(property, name = "log_forwards")]
    fn log_forwards(&self) -> zbus::Result<Vec<zbus::zvariant::OwnedObjectPath>>;

    /// log_verbosity property
    #[dbus_proxy(property, name = "log_verbosity")]
    fn log_verbosity(&self) -> zbus::Result<LogLevel>;
    fn set_log_verbosity(&self, value: LogLevel) -> fdo::Result<()>;

    /// owner property
    #[dbus_proxy(property, name = "owner")]
    fn owner(&self) -> zbus::Result<u32>;

    /// public_access property
    #[dbus_proxy(property, name = "public_access")]
    fn public_access(&self) -> zbus::Result<bool>;
    fn set_public_access(&self, value: bool) -> fdo::Result<()>;

    /// restrict_log_access property
    #[dbus_proxy(property, name = "restrict_log_access")]
    fn restrict_log_access(&self) -> zbus::Result<bool>;
    fn set_restrict_log_access(&self, value: bool) -> fdo::Result<()>;

    /// session_created property
    #[dbus_proxy(property, name = "session_created")]
    fn session_created(&self) -> zbus::Result<u64>;

    /// session_name property
    #[dbus_proxy(property, name = "session_name")]
    fn session_name(&self) -> zbus::Result<String>;

    /// statistics property
    #[dbus_proxy(property, name = "statistics")]
    fn statistics(&self) -> zbus::Result<std::collections::HashMap<String, i64>>;

    /// status property
    #[dbus_proxy(property, name = "status")]
    fn status(&self) -> zbus::Result<Status>;
}

#[derive(Debug, Type, Serialize, Deserialize, PartialEq)]
pub struct Status {
    pub code_major: StatusMajor,
    pub code_minor: StatusMinor,
    pub status_message: String,
}

impl TryFrom<(u32, u32, String)> for Status {
    type Error = <u32 as TryFrom<OwnedValue>>::Error;

    fn try_from(v: (u32, u32, String)) -> std::result::Result<Self, Self::Error> {
        Ok(Self {
            code_major: unsafe { std::mem::transmute(<u32>::try_from(v.0)?) },
            code_minor: unsafe { std::mem::transmute(<u32>::try_from(v.1)?) },
            status_message: v.2,
        })
    }
}

impl TryFrom<OwnedValue> for Status {
    type Error = zbus::Error;

    fn try_from(v: OwnedValue) -> std::result::Result<Self, Self::Error> {
        let v: (u32, u32, String) = v.try_into()?;
        Ok(Status::try_from(v)?)
    }
}

assert_impl_all!(Status: Send, Sync, Unpin);

impl fmt::Display for Status {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "[{}] {} ({})",
            self.code_major, self.code_minor, self.status_message
        )
    }
}

impl fmt::Display for StatusChangeArgs<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.message().len() > 0 {
            write!(
                f,
                "{}, {}: {}",
                self.code_major(),
                self.code_minor(),
                self.message()
            )
        } else {
            write!(f, "{}, {}", self.code_major(), self.code_minor())
        }
    }
}
